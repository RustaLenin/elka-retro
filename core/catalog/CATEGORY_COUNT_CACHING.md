# Кеширование количества типов игрушек в категориях

## Проблема

На старте проекта не все категории будут наполнены типами игрушек. Для улучшения UX необходимо показывать количество типов игрушек в каждой категории, чтобы пользователь мог видеть, в каких категориях есть товары, а в каких нет.

### Текущая ситуация

- Типы игрушек (`toy_type`) связаны с категориями через таксономию `category-of-toys` (иерархическая)
- Экземпляры (`toy_instance`) не привязаны напрямую к категориям
- У типа игрушки есть поле `available_instances_count` — кешированное количество доступных экземпляров
- Нужно учитывать только те типы, которые имеют хотя бы 1 доступный экземпляр (`available_instances_count > 0`)

### Требования

1. **Производительность**: Не должно быть N+1 запросов (по запросу на каждую категорию)
2. **Актуальность**: Счетчики должны обновляться при изменении данных
3. **Надежность**: Должен быть механизм восстановления данных при сбоях
4. **Масштабируемость**: Решение должно работать эффективно при большом количестве категорий (100-500)

## Решение: Кеширование в term meta

### Архитектура

Аналогично существующему классу `ELKARETRO_INSTANCES_COUNTER`, который кеширует количество доступных экземпляров для каждого типа игрушки.

#### Ключевые компоненты

1. **Класс `ELKARETRO_CATEGORY_COUNTER`**
   - Подсчет и кеширование количества типов игрушек в каждой категории
   - Автоматическое обновление при изменении данных
   - CRON для периодического пересчета

2. **Поле для хранения счетчика**
   - **Название**: `toy_types_count`
   - **Тип**: term meta (для таксономии `category-of-toys`)
   - **Формат**: integer (количество типов с `available_instances_count > 0`)

3. **Механизм обновления**
   - Хуки WordPress для отслеживания изменений
   - CRON для ежедневного пересчета (подстраховка)

### Детали реализации

#### Логика подсчета

Для каждой категории считаем:
```php
COUNT(toy_type.id) 
WHERE 
  toy_type имеет связь с категорией через taxonomy 'category-of-toys'
  AND toy_type.post_status = 'publish'
  AND toy_type.meta_value('available_instances_count') > 0
```

**Важно**: Учитываются только опубликованные типы игрушек с хотя бы одним доступным экземпляром.

#### Иерархия категорий

Так как `category-of-toys` — иерархическая таксономия, нужно учесть:

1. **Прямые типы**: Типы, привязанные непосредственно к категории
2. **Дочерние категории**: При подсчете родительской категории можно не учитывать типы из дочерних (или учитывать — зависит от требований UI)

**Реализация по умолчанию**: Считаем только прямые типы (не учитываем типы из дочерних категорий). Если понадобится иначе — можно добавить опцию.

#### Триггеры обновления

Счетчик обновляется в следующих случаях:

1. **При сохранении типа игрушки** (`save_post_toy_type`)
   - Если изменились категории типа → обновляем счетчики для всех затронутых категорий
   - Если изменился `available_instances_count` → обновляем счетчики для всех категорий типа

2. **При изменении связи типа с категорией** (`set_object_terms`)
   - Когда добавляется/удаляется связь типа с категорией
   - Обновляем счетчики для затронутых категорий

3. **При изменении статуса типа** (`transition_post_status`)
   - Если тип опубликован/скрыт → обновляем счетчики для всех категорий типа

4. **При обновлении `available_instances_count`** (через `ELKARETRO_INSTANCES_COUNTER`)
   - Когда счетчик экземпляров меняется с 0 на >0 или наоборот
   - Обновляем счетчики для всех категорий типа

5. **CRON для периодического пересчета** (ежедневно)
   - Полный пересчет всех счетчиков для надежности
   - Компенсирует возможные пропуски при сбоях

#### Методы класса

```php
class ELKARETRO_CATEGORY_COUNTER {
    const FIELD_NAME = 'toy_types_count';
    const CRON_HOOK = 'elkaretro_recalculate_category_counts';
    
    // Инициализация хуков
    public static function init()
    
    // Подсчет типов в категории
    public static function count_toy_types_in_category($category_id)
    
    // Обновление счетчика для категории
    public static function update_category_count($category_id)
    
    // Обновление счетчиков для всех категорий типа
    public static function update_toy_type_categories($toy_type_id)
    
    // Полный пересчет всех категорий
    public static function recalculate_all_categories()
    
    // CRON задача
    public static function cron_recalculate_all()
    
    // Хуки для отслеживания изменений
    public static function handle_toy_type_save($post_id, $post)
    public static function handle_toy_type_categories_change($object_id, $terms, $tt_ids, $taxonomy)
    public static function handle_toy_type_status_change($new_status, $old_status, $post)
    public static function handle_instances_count_change($toy_type_id)
}
```

### Интеграция с существующим кодом

#### Зависимости

- **`ELKARETRO_INSTANCES_COUNTER`**: Используем поле `available_instances_count`, которое обновляется этим классом
- **WordPress Hooks**: `save_post_toy_type`, `set_object_terms`, `transition_post_status`

#### Хук для отслеживания изменений `available_instances_count`

Нужно добавить в `ELKARETRO_INSTANCES_COUNTER` возможность уведомлять другие компоненты об изменении счетчика:

```php
// В ELKARETRO_INSTANCES_COUNTER::update_instances_count()
do_action('elkaretro_instances_count_updated', $toy_type_id, $count);
```

Затем в `ELKARETRO_CATEGORY_COUNTER`:
```php
add_action('elkaretro_instances_count_updated', array(__CLASS__, 'handle_instances_count_change'), 10, 2);
```

### API для получения счетчиков

#### Для фронтенда (REST API)

Обновить `elkaretro_get_taxonomy_terms_for_js()` чтобы включать `toy_types_count`:

```php
$term_data = array(
    'id' => $term->term_id,
    'name' => $term->name,
    'slug' => $term->slug,
    'parent' => $term->parent,
    'toy_types_count' => (int) get_term_meta($term->term_id, 'toy_types_count', true),
);
```

#### Для PHP кода

```php
$count = get_term_meta($category_id, 'toy_types_count', true);
$count = (int) ($count ?: 0);
```

### План внедрения

1. **Этап 1: Создание класса**
   - Создать файл `core/catalog/category-counter.php`
   - Реализовать основные методы подсчета и кеширования
   - Добавить хуки для отслеживания изменений

2. **Этап 2: Интеграция с существующим кодом**
   - Добавить хук в `ELKARETRO_INSTANCES_COUNTER` для уведомления об изменениях
   - Зарегистрировать класс в `functions.php`

3. **Этап 3: Первичная инициализация**
   - Создать функцию для первоначального заполнения счетчиков
   - Вызвать при активации темы или через WP-CLI

4. **Этап 4: Обновление REST API**
   - Модифицировать `elkaretro_get_taxonomy_terms_for_js()` для включения счетчиков
   - Проверить, что фронтенд корректно отображает счетчики

5. **Этап 5: Тестирование**
   - Проверить корректность подсчета
   - Проверить обновление при изменении данных
   - Проверить работу CRON

### Миграция данных

Для существующих данных нужна функция для первоначального заполнения:

```php
ELKARETRO_CATEGORY_COUNTER::recalculate_all_categories();
```

Можно вызвать:
- При активации темы (`after_switch_theme`)
- Через WP-CLI команду (для ручного запуска)
- Через админ-панель (опционально)

### Производительность

#### Оценка нагрузки

- **Количество категорий**: 100-500
- **Количество типов**: ~1000+
- **Частота обновления**: При каждом изменении типа (~10-50 раз в день)
- **CRON**: 1 раз в день

#### Оптимизации

1. **Batch updates**: При массовых операциях обновлять счетчики одним запросом
2. **Кеширование**: Использовать WordPress object cache для счетчиков
3. **Lazy loading**: Загружать счетчики только когда они нужны (для фронтенда)

### Обработка ошибок

- **Невалидный category_id**: Проверять существование категории перед обновлением
- **Ошибки при обновлении**: Логировать, но не прерывать выполнение
- **CRON сбои**: Повторная попытка при следующем запуске

### Мониторинг

Логировать:
- Количество обновленных категорий при пересчете
- Ошибки при обновлении счетчиков
- Время выполнения CRON задачи

### Будущие улучшения

1. **Веб-интерфейс для ручного пересчета** (опционально)
2. **WP-CLI команды** для управления счетчиками
3. **Метрики** для отслеживания производительности
4. **Кеширование дочерних категорий** (если понадобится)

## Примеры использования

### Получение счетчика для категории

```php
// Получить количество типов в категории
$category_id = 123;
$count = get_term_meta($category_id, 'toy_types_count', true);
$count = (int) ($count ?: 0);
echo "В категории {$count} типов игрушек";
```

### Обновление счетчика для категории

```php
// Обновить счетчик для конкретной категории
ELKARETRO_CATEGORY_COUNTER::update_category_count($category_id);
```

### Полный пересчет всех категорий

```php
// Пересчитать счетчики для всех категорий
ELKARETRO_CATEGORY_COUNTER::recalculate_all_categories();
```

### Получение счетчиков для фронтенда

```javascript
// На фронтенде счетчики уже будут в window.taxonomy_terms
const categories = window.taxonomy_terms['category-of-toys'];
Object.values(categories).forEach(category => {
    console.log(`${category.name}: ${category.toy_types_count || 0} типов`);
});
```

## Примечания

### Иерархические категории

При подсчете учитываются только прямые типы категории, не типы из дочерних категорий. Если нужна иная логика (например, включать дочерние категории), можно добавить опцию `include_children` в методы класса.

### Пустые категории

Если в категории нет типов с доступными экземплярами, счетчик будет равен `0`. Это нормально и ожидаемо для пустых категорий.

### Производительность пересчета

Полный пересчет всех категорий может быть медленным при большом количестве категорий и типов. Поэтому:
- CRON запускается ночью (когда нагрузка минимальна)
- Инкрементальные обновления при изменениях очень быстрые
- Для первоначальной инициализации рекомендуется использовать WP-CLI команду

