# Логика обработки заказа на BackEnd

Пошаговое описание того, что происходит при получении запроса на создание заказа с фронтенда.

## Endpoint

**POST** `/wp-json/elkaretro/v1/orders`

**Контроллер:** `Order_REST_Controller::create_order()`

**Сервис:** `Order_Service::create_order()`

---

## Пошаговая обработка заказа

### Шаг 1: Получение и валидация запроса

**Файл:** `core/orders/order-rest-controller.php`

1. **Получение данных:**
   ```php
   $order_data = $request->get_json_params();
   ```

2. **Валидация структуры корзины:**
   - Проверка, что `cart` является объектом
   - Проверка, что `cart.items` является массивом
   - Проверка, что `cart.items` не пустой
   - Если валидация не прошла → возврат ошибки `rest_invalid_cart` (400)

---

### Шаг 2: Проверка авторизации пользователя

**Файл:** `core/orders/order-service.php` → `create_order()`

1. **Получение текущего пользователя:**
   ```php
   $user_id = get_current_user_id();
   ```

2. **Если пользователь НЕ авторизован:**
   - Проверка наличия `order_data['personal']`
   - Если есть → регистрация пользователя через `register_user_for_order()`
   - Если нет → возврат ошибки `order_requires_auth` (400)

3. **Если пользователь авторизован:**
   - Проверка наличия `order_data['personal']`
   - Если есть → обновление недостающих полей профиля через `update_missing_user_profile_fields()`

**Результат:** `$user_id` определен (либо существующий, либо новый)

---

### Шаг 3: Валидация корзины

**Файл:** `core/orders/order-service.php` → `create_order()`

1. **Проверка наличия корзины:**
   ```php
   if ( ! isset( $order_data['cart'] ) || ! isset( $order_data['cart']['items'] ) || empty( $order_data['cart']['items'] ) ) {
       return new WP_Error( 'order_empty_cart', ... );
   }
   ```
   - Если корзина пуста → возврат ошибки `order_empty_cart` (400)

---

### Шаг 3: Валидация и бронирование товаров

**Файл:** `core/orders/order-service.php` → `validate_and_book_items()`

**Цель:** Защита от race conditions путем немедленного бронирования товаров во время валидации.

1. **Проверка каждого товара:**
   - **toy_instance:** Должен иметь статус `publish` или `booked`
   - **ny_accessory:** Должен иметь статус `publish` или `booked` И `stock > 0`

2. **Немедленное бронирование:**
   - Если товар имеет статус `publish` → сразу меняем на `booked`
   - Сохраняем список забронированных товаров для возможного отката

3. **Если валидация не прошла:**
   - Вызывается `rollback_booked_items()` для отката всех забронированных товаров обратно в `publish`
   - Возвращается `WP_Error` с кодом `order_item_unavailable` или `order_item_out_of_stock`
   - Заказ не создается

**Статус `booked`:** Временный промежуточный статус, который защищает от одновременного заказа одного товара несколькими пользователями.

---

### Шаг 4: Валидация и пересчет цен

**Файл:** `core/orders/order-service.php` → `validate_and_recalculate_prices()`

**Цель:** Пересчитать сумму заказа на основе актуальных цен из БД, не доверяя данным с фронтенда.

1. **Получение актуальных цен:**
   - Для каждого товара получаем цену из БД через `get_item_price_from_db()`
   - **toy_instance:** Цена из мета-поля `cost`
   - **ny_accessory:** Цена из мета-поля `ny_cost` (может быть массивом или строкой)

2. **Сравнение цен:**
   - Сравниваем цену с фронтенда с ценой из БД
   - Если разница > 0.01 → отмечаем `price_changed = true`

3. **Пересчет итогов:**
   - Пересчитываем `subtotal` на основе актуальных цен
   - Сохраняем `discount` и `fee` из фронтенда (они не меняются)
   - Пересчитываем `total = subtotal - discount + fee`

4. **Результат:**
   - Возвращается массив с `price_changed` (bool) и `actual_totals` (array)
   - Заказ всегда создается с актуальными ценами из БД, даже если они изменились

**Важно:** Заказ создается с актуальными ценами из БД, независимо от того, что отправил фронтенд.

---

### Шаг 5: Генерация номера заказа

**Это критический шаг!** Проверяется каждый товар из корзины:

#### Для `toy_instance`:
1. ✅ **Проверка существования:**
   - Товар существует в БД
   - Тип поста = `toy_instance`
   - Если нет → ошибка `order_item_not_found` (404)

2. ✅ **Проверка статуса:**
   - Статус поста = `publish` (доступен для заказа)
   - Если статус не `publish` → ошибка `order_item_unavailable` (400)
   - **Важно:** Если товар уже `reserved` или `sold` → заказ прерывается!

#### Для `ny_accessory`:
1. ✅ **Проверка существования:**
   - Товар существует в БД
   - Тип поста = `ny_accessory`
   - Если нет → ошибка `order_item_not_found` (404)

2. ✅ **Проверка статуса:**
   - Статус поста = `publish` (доступен для заказа)
   - Если статус не `publish` → ошибка `order_item_unavailable` (400)

3. ✅ **Проверка остатка:**
   - Получение `stock` из мета-поля
   - Проверка: `stock > 0`
   - Если `stock <= 0` → ошибка `order_item_out_of_stock` (400)

**Результат валидации:**
- ✅ Если все товары валидны → продолжаем
- ❌ Если хотя бы один товар невалиден → **заказ прерывается**, возвращается ошибка

**⚠️ ВАЖНО:** Заказ создается **только если ВСЕ товары валидны**. Частичное создание заказа (без невалидных товаров) **НЕ реализовано**.

**Файл:** `core/orders/order-service.php` → `validate_and_recalculate_prices()`

**Цель:** Пересчитать сумму заказа на основе актуальных цен из БД, не доверяя данным с фронтенда.

1. **Получение актуальных цен:**
   - Для каждого товара получаем цену из БД через `get_item_price_from_db()`
   - **toy_instance:** Цена из мета-поля `cost`
   - **ny_accessory:** Цена из мета-поля `ny_cost` (может быть массивом или строкой)

2. **Сравнение цен:**
   - Сравниваем цену с фронтенда с ценой из БД
   - Если разница > 0.01 → отмечаем `price_changed = true`

3. **Пересчет итогов:**
   - Пересчитываем `subtotal` на основе актуальных цен
   - Сохраняем `discount` и `fee` из фронтенда (они не меняются)
   - Пересчитываем `total = subtotal - discount + fee`

4. **Результат:**
   - Возвращается массив с `price_changed` (bool) и `actual_totals` (array)
   - Заказ всегда создается с актуальными ценами из БД, даже если они изменились

**Важно:** Заказ создается с актуальными ценами из БД, независимо от того, что отправил фронтенд.

---

### Шаг 5: Генерация номера заказа

**Файл:** `core/orders/order-service.php` → `generate_order_number()`

1. Формат: `ORD-YYYYMMDD-XXXX` (например, `ORD-20240115-0001`)
2. Автоматический инкремент для каждого дня

---

### Шаг 6: Подготовка данных для PODS

**Файл:** `core/orders/order-service.php` → `prepare_order_for_pods()`

1. **Разделение товаров по типам:**
   - `toy_instance_items` → массив ID экземпляров
   - `ny_accessory_items` → массив ID аксессуаров

2. **Подготовка данных доставки:**
   - Форматирование адреса (полный и отдельные поля)

3. **Подготовка данных оплаты:**
   - Способ оплаты
   - Детали оплаты

4. **Подготовка итогов:**
   - Сумма товаров
   - Скидка
   - Комиссия
   - Итого

---

### Шаг 8: Создание поста заказа

**Файл:** `core/orders/order-service.php` → `create_order()`

```php
$order_id = wp_insert_post( array(
    'post_type'   => 'elkaretro_order',
    'post_status' => 'awaiting_payment',
    'post_title'  => 'Order #ORD-...',
    'post_author' => $user_id,
) );
```

- Если создание не удалось → **откат всех забронированных товаров** (`rollback_booked_items()`), возврат ошибки `order_creation_failed` (500)

---

### Шаг 9: Сохранение полей заказа в PODS

**Файл:** `core/orders/order-service.php` → `save_order_fields()`

1. **Сохранение базовых полей:**
   - Номер заказа
   - Пользователь
   - Суммы (итого, без скидок, скидка, комиссия)
   - Доставка (метод, адрес, отдельные поля)
   - Оплата (метод, детали)

2. **Сохранение товаров:**
   - `toy_instance_items` → массив ID
   - `ny_accessory_items` → массив ID

3. **Изменение статусов товаров:**
   - **Для `toy_instance`:**
     - Статус меняется с `booked` → `reserved` (товары уже забронированы на шаге 3)
     - Сохранение `_order_id` в мета-поле экземпляра
   
   - **Для `ny_accessory`:**
     - Уменьшение остатка `stock` на 1
     - Если `stock` стал 0 → статус меняется с `booked` → `reserved`
     - Если `stock > 0` → статус меняется с `booked` → `publish` (возврат в продажу)
     - Сохранение `_order_id` в мета-поле аксессуара

**Важно:** Товары уже имеют статус `booked` после валидации (шаг 3). На этом этапе происходит финальное изменение статуса в зависимости от результата заказа.

---

### Шаг 10: Очистка корзины пользователя на BackEnd

**Файл:** `core/orders/order-service.php` → `clear_user_cart()`

1. **Проверка пользователя:**
   - Если `$user_id` не установлен → пропускаем (для неавторизованных корзина в LocalStorage)

2. **Очистка корзины:**
   - Создание пустой корзины: `{ items: [], lastUpdated: ... }`
   - Сохранение в User Meta через `Cart_Service::save_user_cart()`

**Важно:** Корзина очищается на BackEnd **только для авторизованных пользователей**. Для неавторизованных корзина остается в LocalStorage и очищается на фронте.

---

### Шаг 11: Отправка email-уведомлений

**Файл:** `core/orders/order-service.php` → `send_order_created_emails()`

1. **Письмо клиенту:**
   - Тема: "Ваш заказ #XXX принят"
   - Содержит: номер заказа, состав, адрес доставки, итоговая стоимость

2. **Письмо админу:**
   - Тема: "Новый заказ #XXX"
   - Та же информация для администратора
   - **Fallback:** Если отправка на `admin_email` не удалась, отправляется на `lenin-kerrigan@yandex.ru`

**Используется:** `Email_Service::send()` (универсальный сервис отправки)

---

### Шаг 12: Возврат результата

**Файл:** `core/orders/order-rest-controller.php` → `create_order()`

```php
return rest_ensure_response( array(
    'success' => true,
    'order'   => $result, // Полные данные заказа
) );
```

**Если цена изменилась:**
- В `$result` добавляется `price_changed = true`
- В `$result` добавляется `price_change_notice` с текстом: "За время оформления заказа цена изменилась. Актуальную стоимость всех товаров и общую сумму заказа вы увидите в письме."

---

## Ответы на вопросы

### 1. Проверяем ли мы статус заказываемого экземпляра?

**✅ ДА, проверяем И сразу бронируем!**

**Где:** `Order_Service::validate_and_book_items()`

**Что проверяется:**
- Для `toy_instance`: статус должен быть `publish` или `booked`
- Для `ny_accessory`: статус должен быть `publish` или `booked` И `stock > 0`

**Что происходит во время валидации:**
- ✅ Если товар имеет статус `publish` → **немедленно меняем на `booked`**
- ✅ Сохраняем список забронированных товаров для возможного отката
- ✅ **Защита от race conditions:** товары бронируются сразу, другие пользователи не смогут их заказать

**Что происходит, если товар невалиден:**
- ❌ **Откат всех уже забронированных товаров** обратно в `publish` (`rollback_booked_items()`)
- ❌ **Заказ прерывается полностью**
- ❌ Возвращается ошибка (400 или 404)
- ❌ Заказ НЕ создается
- ❌ Корзина НЕ очищается

**Что происходит, если создание заказа не удалось:**
- ❌ **Откат всех забронированных товаров** обратно в `publish` (`rollback_booked_items()`)
- ❌ Возвращается ошибка `order_creation_failed` (500)

**Статус `booked`:** Временный промежуточный статус, который защищает от одновременного заказа одного товара несколькими пользователями. Добавлен в `data-model.json`.

**⚠️ Проблема:** Если в корзине 5 товаров, и один из них стал `reserved` (кто-то другой заказал), то весь заказ отклоняется, даже если остальные 4 товара валидны.

**Рекомендация:** Реализовать частичное создание заказа (создавать заказ только с валидными товарами) или возвращать список невалидных товаров для удаления из корзины.

---

### 2. Обновляем ли состояние корзины при успешном заказе?

**✅ ДА, корзина очищается и на FrontEnd, и на BackEnd!**

**Что происходит:**

**На FrontEnd (после успешного ответа):**
```javascript
// step-confirmation.js
if (result.success && result.order) {
    const store = getCartStore();
    store.clearCart(); // ✅ Очищается на фронте
}
```

**На BackEnd (после успешного создания заказа):**
```php
// order-service.php → create_order()
$this->clear_user_cart( $user_id ); // ✅ Очищается на бекенде
```

**Реализация:**
- ✅ Корзина в User Meta очищается через `Cart_Service::save_user_cart()`
- ✅ Очищается только для авторизованных пользователей
- ✅ Для неавторизованных корзина остается в LocalStorage (очищается на фронте)

**Результат:** При следующей загрузке страницы корзина не восстановится из User Meta, так как она уже очищена на бекенде.

---

### 3. А если заказ не успешный?

**Что происходит с корзиной:**

- ✅ Корзина остается как есть (не изменяется)
- ✅ Товары остаются в корзине
- ✅ Статусы товаров не меняются
- ✅ Остатки не уменьшаются

**Это правильно!** Если заказ не создан, состояние должно остаться прежним.

---

## Что еще может быть не учтено в логике интернет-магазина?

### 1. Частичная валидация товаров

**Проблема:** Если в корзине 10 товаров, и 1 невалиден, весь заказ отклоняется.

**Текущая реализация:**
- ❌ Заказ создается только если ВСЕ товары валидны
- ❌ Пользователь не знает, какой именно товар невалиден

**Решение:**
- Возвращать список невалидных товаров в ошибке
- Предлагать создать заказ без невалидных товаров
- Или создавать заказ частично (только с валидными товарами)

---

### 2. Логирование операций

**Проблема:** Нет истории изменений заказов и товаров.

**Текущая реализация:**
- ❌ Нет логов создания заказов
- ❌ Нет логов изменения статусов товаров
- ❌ Нет логов изменения остатков

**Решение:**
- Добавить логирование всех операций
- Сохранять историю изменений статусов
- Логировать причины отклонения заказов

---

### 3. Откат изменений при ошибке

**Проблема:** Если заказ создан, но отправка email не удалась, статусы товаров уже изменены.

**Текущая реализация:**
- ✅ Заказ создается
- ✅ Статусы товаров меняются
- ✅ Email отправляется
- ❌ Если email не отправился, статусы уже изменены (отката нет)

**Решение:**
- Использовать транзакции БД
- Или реализовать откат изменений при ошибке

---

### 4. Ограничение количества товаров в заказе

**Проблема:** Нет ограничения на количество одного товара в заказе.

**Текущая реализация:**
- ❌ Можно заказать 1000 единиц одного аксессуара
- ❌ Нет проверки разумности количества

**Решение:**
- Добавить максимальное количество на товар
- Проверять количество при валидации

---

### 5. Резервирование товаров

**Проблема:** Товары резервируются сразу при создании заказа, но заказ может быть отменен.

**Текущая реализация:**
- ✅ Товары резервируются сразу
- ❌ Нет механизма освобождения резерва при отмене заказа

**Решение:**
- Реализовать автоматическое освобождение резерва при отмене заказа
- Или использовать временное резервирование (с таймаутом)

---

### 6. Валидация адреса доставки

**Проблема:** Адрес доставки может быть некорректным или неполным.

**Текущая реализация:**
- ❌ Адрес не валидируется
- ❌ Принимается любой текст

**Решение:**
- Добавить валидацию адреса (минимальная длина, обязательные поля)
- Интеграция с API геокодирования для проверки адреса

---

## Рекомендации по приоритетам

### Критично (сделать в первую очередь):

Все критичные задачи выполнены! ✅

### Важно (сделать в ближайшее время):

1. ⚠️ **Частичная валидация** товаров (возвращать список невалидных товаров для удаления из корзины)
2. ⚠️ **Логирование** операций с заказами (история изменений статусов, причины отклонения)
3. ⚠️ **Откат изменений** при ошибке создания заказа (если email не отправился, но заказ создан)

### Желательно (можно отложить):

4. ⚠️ **Резервирование с таймаутом** (автоматическое освобождение резерва при отмене заказа)
5. ⚠️ **Ограничение количества** товаров в заказе (максимальное количество на товар)
6. ⚠️ **Валидация адреса** доставки (минимальная длина, обязательные поля, геокодирование)

---

## Реализованные решения

### ✅ Очистка корзины на BackEnd

**Реализация:** После успешного создания заказа корзина очищается на BackEnd через `Cart_Service::save_user_cart()` для авторизованных пользователей.

**Файлы:** `core/orders/order-service.php` → `clear_user_cart()`

---

### ✅ Защита от race conditions

**Реализация:** Промежуточный статус `booked` для немедленного бронирования товаров во время валидации.

**Файлы:** 
- `core/data-model.json` — добавлен статус `booked`
- `core/orders/order-service.php` → `validate_and_book_items()`, `rollback_booked_items()`

---

### ✅ Валидация цен на бекенде

**Реализация:** Пересчет суммы заказа на основе актуальных цен из БД, не доверяя данным с фронтенда.

**Файлы:** `core/orders/order-service.php` → `validate_and_recalculate_prices()`, `get_item_price_from_db()`

**Особенности:**
- Заказ всегда создается с актуальными ценами из БД
- Если цена изменилась, пользователь получает уведомление в ответе
- Актуальные цены отправляются в email-уведомлении

---

### ✅ Защита от дублирования заказов

**Реализация:** Блокировка кнопки "Завершить заказ" сразу при клике + лоадер с оверлеем.

**Файлы:**
- `components/cart/order-wizard/order-wizard.js` — состояние `isSubmitting`, блокировка кнопки
- `components/cart/order-wizard/steps/step-confirmation.js` — установка `isSubmitting` при создании заказа
- `components/cart/order-wizard/steps/step-confirmation-template.js` — оверлей с лоадером
- `components/cart/order-wizard/steps/step-confirmation-styles.css` — стили оверлея

**Особенности:**
- Кнопка дизейблится сразу при клике (до начала валидации)
- Показывается блокирующий оверлей с лоадером поверх формы
- Кнопка остается заблокированной даже если пользователь как-то снимет оверлей

