# Сравнение логики создания заказа для авторизованных и неавторизованных пользователей

## Общая структура

Оба типа пользователей используют **один и тот же метод** `Order_Service::create_order()`, который обрабатывает оба случая.

---

## Различия в обработке пользователя

### Неавторизованные пользователи

**Метод:** `register_user_for_order()`

**Что происходит:**
1. ✅ Проверка наличия обязательных полей: `email`, `username`, `password`
2. ✅ Проверка уникальности email и username
3. ✅ Создание пользователя через `wp_create_user()`
4. ✅ Сохранение дополнительных данных в user meta:
   - `phone_number` (если передан `phone`)
   - `first_name` (если передан)
   - `last_name` (если передан)
5. ✅ **Автоматический логин** пользователя:
   ```php
   wp_set_current_user( $user_id );
   wp_set_auth_cookie( $user_id );
   ```

**Результат:** Пользователь создан и автоматически авторизован.

---

### Авторизованные пользователи

**Метод:** `update_missing_user_profile_fields()`

**Что происходит:**
1. ✅ Обновление **только пустых** полей в профиле:
   - `phone_number` (если поле пустое и передан `phone`)
   - `first_name` (если поле пустое и передан)
   - `last_name` (если поле пустое и передан)
2. ❌ **НЕ обновляет** существующие поля (даже если в форме указаны другие значения)

**Результат:** Профиль дополнен недостающими данными, существующие данные не изменяются.

---

## Общая логика (одинаковая для обоих)

После получения/создания `$user_id` дальнейшая обработка **полностью идентична**:

1. ✅ **Валидация корзины** - проверка наличия товаров
2. ✅ **Валидация и бронирование товаров** - проверка доступности, изменение статуса на `booked`
3. ✅ **Пересчет цен** - получение актуальных цен из БД, сравнение с фронтендом
4. ✅ **Генерация номера заказа** - уникальный номер через `wp_option`
5. ✅ **Создание заказа** - `wp_insert_post()` с `post_author = $user_id`
6. ✅ **Сохранение полей в PODS** - все данные заказа, включая relationship поля
7. ✅ **Очистка корзины** - `clear_user_cart($user_id)` для обоих случаев
8. ✅ **Отправка писем** - клиенту и администратору
9. ✅ **Обработка изменения цен** - уведомление, если цены изменились

---

## Потенциальные проблемы и различия

### 1. Автоматический логин для неавторизованных

**Текущее поведение:** После регистрации пользователь автоматически логинится.

**Вопрос:** Соответствует ли это бизнес-логике? Возможно, пользователь не хочет автоматически логиниться после оформления заказа.

**Рекомендация:** Если это нежелательно, убрать строки:
```php
wp_set_current_user( $user_id );
wp_set_auth_cookie( $user_id );
```

---

### 2. Обновление профиля для авторизованных

**Текущее поведение:** Обновляются только **пустые** поля. Если в профиле уже есть телефон, он не обновляется даже если в форме указан другой.

**Вопрос:** Правильно ли это? Возможно, нужно обновлять поля, если они переданы в форме заказа?

**Текущая логика:**
```php
$current = get_user_meta( $user_id, $config['meta_key'], true );
if ( empty( $current ) ) {
    update_user_meta( $user_id, $config['meta_key'], $value );
}
```

**Альтернатива:** Обновлять всегда, если значение передано:
```php
if ( ! empty( $value ) ) {
    update_user_meta( $user_id, $config['meta_key'], $value );
}
```

---

### 3. Очистка корзины

**Текущее поведение:** Корзина очищается для обоих типов пользователей через `clear_user_cart($user_id)`.

**Проверка:** ✅ Работает одинаково для обоих случаев.

---

### 4. Отправка писем

**Текущее поведение:** Письма отправляются клиенту на `$user->user_email` и администратору.

**Проверка:** ✅ Работает одинаково для обоих случаев (после регистрации у неавторизованного пользователя есть email).

---

### 5. Сохранение данных заказа

**Текущее поведение:** Все данные сохраняются одинаково через `save_order_fields()`:
- `user` (relationship field) - привязка пользователя
- `toy_instance_items` (relationship field) - привязка экземпляров
- `ny_accessory_items` (relationship field) - привязка аксессуаров
- Все остальные поля (адрес, способ оплаты, суммы и т.д.)

**Проверка:** ✅ Работает одинаково для обоих случаев.

---

## Выводы

### ✅ Что работает одинаково:
1. Валидация корзины
2. Валидация и бронирование товаров
3. Пересчет цен
4. Генерация номера заказа
5. Создание заказа
6. Сохранение полей в PODS
7. Очистка корзины
8. Отправка писем
9. Обработка ошибок и rollback

### ⚠️ Различия (по дизайну, подтверждено как корректное):
1. **Регистрация vs обновление профиля** - разная логика, но это ожидаемо
2. **Автоматический логин** - только для неавторизованных ✅ **Подтверждено: корректное поведение**
3. **Обновление профиля** - только пустые поля обновляются ✅ **Подтверждено: корректное поведение**

---

## Обработка на фронтенде

### Общая логика (одинаковая для обоих случаев)

**Файл:** `components/cart/order-wizard/steps/step-confirmation.js`

#### 1. Подготовка данных заказа

**Метод:** `prepareOrderData()`

**Что происходит:**
- ✅ Формирование данных корзины (одинаково для обоих)
- ✅ Передача `personal` данных (если есть)
- ✅ Передача `delivery` данных
- ✅ Передача `payment` данных
- ✅ Передача `totals` (суммы)

**Различия:** Нет различий - данные формируются одинаково, просто для авторизованных `personal` может не содержать `password`.

#### 2. Отправка запроса

**Эндпоинт:** `/wp-json/elkaretro/v1/orders` (один и тот же для обоих случаев)

**Метод:** `createOrder()`

**Что происходит:**
- ✅ Одинаковый URL для обоих случаев
- ✅ Одинаковые заголовки (включая `X-WP-Nonce`)
- ✅ Одинаковая структура данных в body

**Различия:** Нет различий - используется один эндпоинт, который сам определяет, авторизован пользователь или нет.

#### 3. Обработка успешного создания заказа

**Что происходит:**
- ✅ Установка `success: true` и `orderId` в state
- ✅ Сброс `isSubmitting: false`
- ✅ Очистка корзины через `store.clearCart()`
- ✅ Очистка прогресса Wizard из localStorage
- ✅ Перерисовка компонента для отображения сообщения об успехе
- ✅ Отправка события `elkaretro:order:created`

**Различия:** Нет различий - обработка полностью идентична.

#### 4. Обработка ошибок

**Что происходит:**
- ✅ Установка `error` в state с текстом ошибки
- ✅ Сброс `isSubmitting: false` в компоненте
- ✅ Сброс `isSubmitting: false` в wizard
- ✅ Перерисовка компонента для отображения ошибки

**Различия:** Нет различий - обработка полностью идентична.

#### 5. Отображение UI

**Шаблон:** `step-confirmation-template.js`

**Успешное создание:**
- ✅ Показ сообщения "Заказ успешно создан!"
- ✅ Отображение номера заказа
- ✅ Ссылка "Вернуться на главную"

**Ошибка:**
- ✅ Показ блока с ошибкой
- ✅ Текст ошибки из state

**Загрузка:**
- ✅ Показ оверлея с лоадером "Создание заказа..."

**Различия:** Нет различий - UI одинаковый для обоих случаев.

---

## Рекомендации

1. ✅ **Текущая реализация корректна** - общая логика одинаковая, различия только в обработке пользователя
2. ✅ **Бизнес-логика подтверждена:**
   - Автоматический логин после регистрации - **корректное поведение**
   - Обновление только пустых полей профиля - **корректное поведение**
3. ✅ **Все критичные операции** (валидация, бронирование, создание заказа, очистка корзины, отправка писем) работают одинаково для обоих типов пользователей
4. ✅ **Обработка на фронтенде** полностью идентична для обоих случаев - нет различий в логике успеха/ошибки/UI

