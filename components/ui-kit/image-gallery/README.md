# Image Gallery Component

Компонент галереи изображений с миниатюрами, полноэкранным режимом и плавными переходами.

## Особенности реализации

### 1. Наследование от HTMLElement (не BaseElement)

Компонент **не наследуется от `BaseElement`**, а напрямую от `HTMLElement`. Это сделано специально для упрощения логики и избежания конфликтов с автоматическим рендерингом.

**Причина:** Компонент требует ручного управления DOM при переключении изображений (fade-эффект), и автоматический рендер из `BaseElement` создавал конфликты и зацикливания.

### 2. Предзагрузка изображений

Все изображения предзагружаются в фоне при рендере компонента:

```javascript
_preloadImages() {
  // Создается скрытый контейнер
  // Все изображения загружаются в кеш браузера
  // При переключении изображение уже в кеше - мгновенная замена
}
```

**Преимущества:**
- Мгновенное переключение изображений (нет задержки загрузки)
- Плавный fade-эффект без "мигания"
- Минимум логики при переключении

### 3. Простое переключение изображений

Логика переключения максимально упрощена:

1. **Fade-out** текущего изображения (opacity: 0)
2. После `transitionend` → меняем `src` (изображение уже в кеше)
3. **Fade-in** нового изображения (opacity: 1)

**Нет:**
- Двойного буфера с swap'ами
- Сложных состояний
- Множественных `setTimeout`
- Управления через `setState()`

**Есть:**
- Прямое управление DOM через `style.opacity`
- CSS transitions для анимации
- Событие `transitionend` для синхронизации

### 4. Синхронизация индекса и миниатюр

При переключении изображений:
- Индекс обновляется **сразу** (`this._data.currentIndex = newIndex`)
- Миниатюры обновляются **сразу** (`_updateThumbnails(newIndex)`)
- Подпись обновляется **сразу** (`_updateCaption(newImage)`)

Это гарантирует, что визуально активная миниатюра всегда соответствует текущему изображению, даже во время анимации.

### 5. Полноэкранный режим

Полноэкранный режим работает по той же логике, что и обычный:

- Overlay создается в шаблоне при `fullscreen: true`
- При открытии/закрытии вызывается `_render()` для создания/скрытия overlay
- Переключение изображений работает одинаково в обоих режимах через `_updateImageInMode(isFullscreen, newIndex)`

## Использование

### 1. Через глобальный стейт (приоритет 1)

```html
<ui-image-gallery state-path="toyType.all_images"></ui-image-gallery>
<ui-image-gallery state-path="toyInstance.images"></ui-image-gallery>
```

Компонент автоматически подписывается на события:
- `app-state-changed`
- `app-state-toy-type-loaded`
- `app-state-toy-instance-loaded`

### 2. Через атрибут images (JSON)

```html
<ui-image-gallery images='[{"url": "...", "alt": "...", "thumbnail": "..."}, ...]'></ui-image-gallery>
```

### 3. Через метод setImages()

```javascript
const gallery = document.querySelector('ui-image-gallery');
gallery.setImages([
  {url: 'image1.jpg', alt: 'Image 1', thumbnail: 'thumb1.jpg'},
  {url: 'image2.jpg', alt: 'Image 2', thumbnail: 'thumb2.jpg'}
]);
```

### 4. Через image-ids (WordPress Media IDs)

```html
<ui-image-gallery image-ids='[123, 456, 789]'></ui-image-gallery>
```

Изображения загружаются через WordPress REST API (`/wp-json/wp/v2/media/{id}`).

## Проблемы и решения

### Проблема 1: Зацикливание и мигание при переключении

**Симптомы:**
- Компонент полностью перерисовывается при каждом переключении
- Overlay мигает/исчезает
- Зацикливание анимаций

**Причина:**
- `BaseElement.setState()` вызывал автоматический `render()`
- `render()` пересоздавал весь DOM, включая overlay
- Конфликты между ручным управлением DOM и автоматическим рендером

**Решение:**
- Отказ от `BaseElement`, наследование от `HTMLElement`
- Ручное управление DOM через `style.opacity`
- `render()` вызывается только при изменении структуры (images, fullscreen)
- Переключение изображений обновляет только содержимое, не структуру

### Проблема 2: Рассинхронизация индекса и миниатюр

**Симптомы:**
- Активная миниатюра не соответствует текущему изображению
- После переключения рамка "откатывается" на предыдущую миниатюру

**Причина:**
- Индекс обновлялся асинхронно (в `setTimeout` или после анимации)
- Миниатюры обновлялись отдельно от индекса

**Решение:**
- Индекс и миниатюры обновляются **сразу** при клике (до анимации)
- Финальное обновление миниатюр после завершения всех анимаций (на случай если overlay создался позже)

### Проблема 3: Потеря рамки активной миниатюры в полноэкранном режиме

**Симптомы:**
- После переключения изображений рамка активной миниатюры исчезает

**Причина:**
- `_updateThumbnails()` не находил полноэкранные миниатюры (overlay мог быть скрыт)
- Миниатюры обновлялись до создания overlay

**Решение:**
- Отдельная обработка обычных и полноэкранных миниатюр в `_updateThumbnails()`
- Финальное обновление миниатюр после завершения всех анимаций
- `querySelectorAll` находит элементы даже если они скрыты через `display: none`

### Проблема 4: Видимая загрузка изображений при переключении

**Симптомы:**
- При переключении видна загрузка нового изображения
- "Мигание" или "прыжок" при смене изображения

**Причина:**
- Изображения загружались только при переключении
- Браузеру нужно время для загрузки нового изображения

**Решение:**
- Предзагрузка всех изображений в фоне при рендере
- Изображения загружаются в скрытый контейнер
- При переключении изображение уже в кеше браузера - мгновенная замена

## Важные детали реализации

### Флаг `_isChangingImage`

Предотвращает параллельные переключения:

```javascript
if (this._isChangingImage) {
  return; // Игнорируем новый запрос
}
```

Флаг устанавливается в начале `_changeImageWithFade()` и сбрасывается после завершения всех анимаций через `Promise.all()`.

### Управление через Promise

`_updateImageInMode()` возвращает Promise, который резолвится после завершения fade-in. Это позволяет:

- Синхронизировать анимации в обычном и полноэкранном режимах
- Сбрасывать флаг `_isChangingImage` только после завершения всех анимаций
- Гарантировать финальное обновление миниатюр

### CSS Transitions

Вся анимация выполняется через CSS:

```css
.image-gallery_main-image {
  transition: opacity 0.3s ease-in-out;
}
```

JavaScript только управляет классами/стилями, CSS делает анимацию. Это более производительно и плавно.

### Предзагрузка в скрытом контейнере

```javascript
preloadContainer.style.cssText = 'position: absolute; width: 0; height: 0; overflow: hidden; opacity: 0; pointer-events: none;';
```

Контейнер невидим и не мешает пользователю, но браузер загружает изображения в кеш.

## Структура файлов

```
image-gallery/
├── image-gallery.js          # Основная логика компонента
├── image-gallery-template.js # HTML шаблон
├── image-gallery-styles.css  # Стили компонента
└── README.md                 # Эта документация
```

## Стили

Компонент использует CSS переменные из глобального `style.css`:
- `--color-primary` - цвет активной миниатюры
- `--color-secondary` - фон контейнеров
- `--color-foreground` - цвет текста и иконок

## События

Компонент слушает следующие события:

- `app-state-changed` - общее изменение глобального стейта
- `app-state-toy-type-loaded` - загрузка данных типа игрушки
- `app-state-toy-instance-loaded` - загрузка данных экземпляра игрушки

## Методы API

### `setImages(images)`

Устанавливает изображения программно:

```javascript
gallery.setImages([
  {url: 'image1.jpg', alt: 'Image 1', thumbnail: 'thumb1.jpg'},
  {url: 'image2.jpg', alt: 'Image 2', thumbnail: 'thumb2.jpg'}
]);
```

## Известные ограничения

1. **Рендер при открытии/закрытии полноэкранного режима:** При открытии/закрытии полноэкранного режима вызывается `_render()`, что пересоздает весь DOM. Это необходимо для создания/скрытия overlay из шаблона.

2. **Предзагрузка всех изображений:** Все изображения предзагружаются сразу, что может увеличить начальную загрузку страницы. Для больших галерей (100+ изображений) может потребоваться оптимизация (ленивая загрузка следующих изображений).

3. **Одно изображение в DOM:** В отличие от некоторых галерей, которые держат несколько изображений в DOM, здесь используется одно изображение с заменой `src`. Это упрощает логику, но требует предзагрузки для плавности.

## Рекомендации по использованию

1. **Для небольших галерей (< 20 изображений):** Используйте как есть, предзагрузка не создаст проблем.

2. **Для больших галерей (> 50 изображений):** Рассмотрите возможность ленивой предзагрузки (загружать только видимые + несколько следующих).

3. **Для динамических галерей:** Используйте `state-path` для автоматической синхронизации с глобальным стейтом.

4. **Для статических галерей:** Используйте атрибут `images` с JSON.

## Отладка

Если компонент не работает корректно:

1. **Проверьте предзагрузку:** Откройте DevTools → Network, убедитесь, что изображения загружаются.

2. **Проверьте флаг `_isChangingImage`:** Если он "застрял" в `true`, переключение будет заблокировано.

3. **Проверьте наличие элементов:** Убедитесь, что `.image-gallery_main-image--current` и `.image-gallery_fullscreen-image--current` существуют в DOM.

4. **Проверьте события `transitionend`:** Убедитесь, что CSS transition работает (проверьте стили).

## Будущие улучшения

- [ ] Ленивая предзагрузка для больших галерей
- [ ] Поддержка touch-жестов для мобильных устройств
- [ ] Zoom/pan в полноэкранном режиме
- [ ] Поддержка видео в галерее
- [ ] Клавиатурная навигация (стрелки, Home, End)

